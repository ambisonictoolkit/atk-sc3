title:: Ambisonic Enlightenment
summary:: On ways to think Ambisonic, a Novice's guide
categories:: Libraries>Ambisonic Toolkit>Guides & Tutorials
keyword::Atk

section:: Introduction


code::
("https://en.wikipedia.org/wiki/Novice".openOS)
::

section:: Panorama Laws

A emphasis::panorama law::, aka emphasis::panning law::, is a rule detailing how a loudspeaker array synthesizes a spatial sound image. This rule may act by creating emphasis::amplitude::, emphasis::phase:: and emphasis::time:: differences between loudspeakers to synthesize the target image. In practice, not all of these aspects are always touched, and different panning laws may emphasize one aspect over another.

In the discussion here we'll compare emphasis::pair-wise panning:: laws with those returned by Ambisonics. Also, we'll restrict the Ambisonic laws to emphasis::basic:: panning. I.e., sources to be panned and target loudspeakers are at the emphasis::reference radius::.

note::
When we do this, we are reviewing the emphasis::angular:: component of Ambisonic panning laws.

We'll review emphasis::radial:: aspects later.
::

subsection:: Stereo with Pan2

Let's begin with the two channel stereophonic emphasis::sine-cosine panning law::, footnote::link::https://www.researchgate.net/publication/228381059_Classic_stereo_imaging_transforms-a_review##See Classic Stereo Imaging Transformsâ€”A Review::.:: as this is the panning law used by SuperCollider's link::Classes/Pan2:: UGen. From the help, we see this is described as a "Two channel equal power panner". In other words, the panorama effect is a result of acting on the amplitude scaling of an input signal, scaling in an emphasis::equal power:: distribution between two loudspeakers.

If we look at the link::https://github.com/supercollider/supercollider/blob/3.11/server/plugins/PanUGens.cpp#L792-L816#source code::, we can see the function used is emphasis::sine::.

Let's make a plot to visualize...

code::
~size = 4096;  // SC's Pan2 size

~pos = Array.interpolation(~size, -1.0, 1.0);  // pan position

// sine-cosine panning law
(
~sinCosLaw = (pi / 4 * Array.with(
	(~pos.neg + 1),  // left
	(~pos + 1)  // right
)
).sin;
);

// plot!
~sinCosLaw.at(0).plot("sin-cos: left");
~sinCosLaw.at(1).plot("sin-cos: right");
::

What we see is that we have a rule to govern how much signal is passed to the left and right to synthesize a emphasis::phantom image::.


subsection:: Quad with PanAz

Reviewing the help for link::Classes/PanAz::, we see it described as a "Multichannel equal power panner." When we peek at the link::https://github.com/supercollider/supercollider/blob/3.11/server/plugins/PanUGens.cpp#L1304-L1346#source code::, we can see that sine appears.

With the settings listed just below, link::Classes/PanAz:: will return the exact same rule as link::Classes/Pan2:::

code::
PanAz.ar(2, in, pos: (0.5 * ~myPos), level: 1.0, width: 2.0, orientation: 0.5)  // Pan2
::

________________

Given the default arguments, and setting strong::numChans:: to four:

code::
PanAz.ar(4, in, pos: 0.0, level: 1.0, width: 2.0, orientation: 0.5)
::

will return a emphasis::pair-wise equal power:: quadraphonic panning rule.

Let's go ahead and test this panner with link::Classes/DC:: and plot the results. We're starting at the left speaker and panning counter-clockwise all the way around:

code::
s.boot;  // wait for the server to boot...

// Quad w/ PanAz: FL, FR, BR, BL
(
var dur = 0.1;
{
	PanAz.ar(4, DC.ar(1), Line.ar(0.25.neg, 2.25.neg, 0.1), orientation: 0.5)
}.plot(dur)
)
::

What we see here is the amplitude scaling rule for all four speakers in order to pan a sound in a counter-clockwise rotation around the array. We can see that no more than two loudspeakers are active at once.

Also, note that the rule can be described as a collection of emphasis::windows in space:: or emphasis::spatial windows::.

Keep this plot open, as we're going to compare this rule with Ambisonics.


subsection:: Quad with PanB2 & DecodeB2

Here we'll start with two of SuperCollider's FOA built ins link::Classes/PanB2:: and link::Classes/DecodeB2:: to build a quadraphonic panner. footnote::Building a panner by directly connecting an encoder and a decoder is known as emphasis::Ambisonic equivalent panning::, aka emphasis::AEP::.:: This first is a emphasis::basic:: 2D encoder, and the second is a emphasis::controlled opposites::, aka cardioid, 2D decoder:

code::
// Quad w/ PanB2 -> DecodeB2: FL, FR, BR, BL
(
var dur = 0.1;
var numChans = 4;
{
	var foa;
	foa = PanB2.ar(DC.ar(1), Line.ar(0.25.neg, 2.25.neg, 0.1));  // start the law
	DecodeB2.ar(numChans, foa.at(0), foa.at(1), foa.at(2))  // finish the law
}.plot(dur)
)
::

note::We've split the law between link::Classes/PanB2:: & link::Classes/DecodeB2::!::

In comparing the laws for link::#Quad with PanAz:: and link::#Quad with PanB2 & DecodeB2:: we'll notice two things immediately. The spatial windows for :

numberedlist::
## strong::Quad with PanAz:: are sharply clipped
## strong::Quad with PanB2 & DecodeB2:: are very smooth
::

link::Classes/PanAz:: offers a parameter to adjust the amount of clipping by changing its strong::width:: argument. We can modify the law, so it looks a bit more like what we see with link::Classes/PanB2:: and link::Classes/DecodeB2:::

code::
// Quad w/ PanAz: FL, FR, BR, BL
// width = 4
(
var dur = 0.1;
{
	PanAz.ar(4, DC.ar(1), Line.ar(0.25.neg, 2.25.neg, 0.1), width: 4, orientation: 0.5)
}.plot(dur)
)
::

note::
While reduced, there is are still sharp edges in the windows!
::

In emphasis::time domain:: signal processing, sharp window shapes are associated with emphasis::frequency domain aliasing:: footnote::See link::https://en.wikipedia.org/wiki/Window_function##Window function::::.

In the emphasis::spatial domain::, sharp windows are associated with emphasis::spatial domain aliasing::.


subsection:: Optimized Quad with HOA1

The original architects of classic first order Ambisonics were emphasis::deeply concerned:: about the emphasis::spatial domain aliasing:: found in the quad recordings of the link::https://en.wikipedia.org/wiki/Quadraphonic_sound##Age of Quadraphonic Sound::. One of their goals was to reduce or remove the spatial distortions found in these recordings.

Their solution was to offer three different panning laws on finishing off the rule. These choices are equivalent to link::Classes/PanAz::'s strong::width:: parameter, but instead of being an ad hoc choice, the different laws for Ambisonics are defined against optimization criteria.

The ATK uses the parameter name strong::beam shape:: within the HOA toolset. footnote::
The FOA toolset uses the name strong::k::.
note::
We could have called this parameter emphasis::spatial window:: or even emphasis::panning law::. The term emphasis::beam shape:: appears to be a preferred name in the HOA technical literature.
::
::

Three standard emphasis::spatial windows:: are offered:

table::
## strong::keyword:: || strong::beam shape:: || strong::localisation vector:: || strong::virtual microphone::
## code::\basic:: || strict soundfield || maximum velocity rV || Hyper-cardioid
## code::\energy:: || energy optimised || maximum energy rE || Super-cardioid
## code::\controlled:: || controlled opposites || minimum diametric energy || Cardioid
::

In the codeblock immediately below you'll notice that the HOA toolset code for making an emphasis::Ambisonic equivalent panner:: for quad is much more verbose. As a result, we have much greater control.

We'll use the ATK's emphasis::projection decoder::, link::Classes/HoaMatrixDecoder#*newProjection::, to create the quad decoder. link::Classes/HoaMatrixDecoder#*newProjection#newProjection:: is a very simple, but powerful decoder. It quickly calculates the matrices required for decoders where space has been sampled equally. To design a 2D decoder, we just supply the vertices of a regular polygon. footnote::This is what SuperCollider's link::Classes/DecodeB2:: is doing under the hood.::

note::
In practice, we'd usually use link::Classes/HoaMatrixDecoder#*newPanto:: to return a quadraphonic, or other regular polygon, decoder, as it designs the required polygon internally. For ease of comparison we've used link::Classes/HoaMatrixDecoder#*newProjection#newProjection:: for the following examples, so as to directly map to the output ordering link::Classes/PanAz:: returns.
::

Go ahead and try each of the three window choices.

code::
// Quad w/ HOA1: FL, FR, BR, BL
(
var dur = 0.1;
var numChans = 4;
var order = 1;  // ambisonic order
var decoder = HoaMatrixDecoder.newProjection( // design
	Array.regularPolygon(numChans, \side, pi).rotate(1).neg,  // quad
	// \basic,  // strict soundfield
	// \energy,  // energy optimised
	\controlled,  // controlled opposites <- same as DecodeB2
	\amp,
	order
);
{
	var hoa;
	hoa = HoaEncodeDirection.ar(  // start the law
		DC.ar(1),  // DC
		Line.ar(0, 2pi, 0.1, add: pi/4),
		0,
		AtkHoa.refRadius,
		order
	);

	HoaDecodeMatrix.ar(hoa, decoder)  // finish the law
}.plot(dur)
)
::

With emphasis::basic:: and emphasis::energy::, we see the scaling function drops below zero in places. If plotted in a polar form, we'd see the familiar tails of first order hyper-cardiod and super-cardioid microphones.

Look closely to find where these tails appear in the windows. Of particular interest, by dropping below zero they are inverted in polarity. They appear at their peaks when there are a peaks in the loudspeaker opposite. We can say, where one loudspeaker pushes, the opposite pulls.

note::In Ambisonics, the loudspeakers all work together to create the panorama.::

(Feel free to close the open plots.)


subsection:: Octa with PanAz

Let's try a pair-wise link::https://en.wikipedia.org/wiki/Octophonic_sound##octaphanic rule:: with link::Classes/PanAz::.

For convenience, we'll use an array where the first loudspeaker is in at front center, and we'll start the test from directly behind, so that the plot returns the first window centered. As before, the panning angle will rotate counter-clockwise.

code::
// Octa w/ PanAz: FC, ...
(
var dur = 0.1;
{
	PanAz.ar(8, DC.ar(1), Line.ar(1, 1.neg, 0.1), orientation: 0)
}.plot(dur)
)
::

This plot really gives a clear sense that emphasis::panning laws:: are emphasis::spatial windows::. We see each window offset in space. (Keep this plot open.)

Now let's do the same analysis, but just keep the window for the first loudspeaker:

code::
// Octa w/ PanAz: FC only!
(
var dur = 0.1;
{
	PanAz.ar(8, DC.ar(1), Line.ar(1, 1.neg, 0.1), orientation: 0).first
}.plot(dur, minval: -1, maxval: 1)
)
::
(And, keep this plot open, too!)

subsection:: Optimized Octa with HOA3


Go ahead and try each of the three window choices.

code::
// Octa w/ HOA3: FC...
(
var dur = 0.1;
var numChans = 8;
var order = 3;  // ambisonic order
var decoder = HoaMatrixDecoder.newProjection( // design
	Array.regularPolygon(numChans, \vertex, pi).neg,  // octa
	// \basic,  // strict soundfield
	// \energy,  // energy optimised
	\controlled,  // controlled opposites
	\amp,
	order
);
{
	var hoa;
	hoa = HoaEncodeDirection.ar(  // start the law
		DC.ar(1),  // DC
		Line.ar(pi.neg, pi, 0.1),
		0,
		AtkHoa.refRadius,
		order
	);

	HoaDecodeMatrix.ar(hoa, decoder)  // finish the law
}.plot(dur)
)
::
(After inspection, feel free to close these.)

And, another plot, keeping just the front center loudspeaker:

code::
// Octa w/ HOA3: FC only!
(
var dur = 0.1;
var numChans = 8;
var order = 3;  // ambisonic order
var decoder = HoaMatrixDecoder.newProjection( // design
	Array.regularPolygon(numChans, \vertex, pi).neg,  // octa
	// \basic,  // strict soundfield
	// \energy,  // energy optimised
	\controlled,  // controlled opposites
	\amp,
	order
);
{
	var hoa;
	hoa = HoaEncodeDirection.ar(  // start the law
		DC.ar(1),  // DC
		Line.ar(pi.neg, pi, 0.1),
		0,
		AtkHoa.refRadius,
		order
	);

	HoaDecodeMatrix.ar(hoa, decoder).first  // finish the law
}.plot(dur, minval: -1, maxval: 1)
)
::
(After inspection, feel free to close these.)

Let's do one more plot, where we compare the window shape of pair-wise octaphonic with HOA3 emphasis::strict soundfield:::

code::
// Octa w/ PanAz vs HOA3: FC only!
(
var dur = 0.1;
var numChans = 8;
var order = 3;  // ambisonic order
var decoder = HoaMatrixDecoder.newProjection( // design
	Array.regularPolygon(numChans, \vertex, pi).neg,  // octa
	\basic,  // strict soundfield
	\energy,
	order
);
{
	var hoa;
	hoa = HoaEncodeDirection.ar(  // start the law
		DC.ar(1),  // DC
		Line.ar(pi.neg, pi, 0.1),
		0,
		AtkHoa.refRadius,
		order
	);

	Array.with(
		PanAz.ar(8, DC.ar(1), Line.ar(1, 1.neg, 0.1), orientation: 0).first,
		HoaDecodeMatrix.ar(hoa, decoder).first  // finish the law
	)
}.plot(dur, minval: -1, maxval: 1)
)
::

What we're seeing here is that in the main lobe of the two windows, the octaphonic pair-wise law is similar to the HOA3 strict soundfield law. That's interesting, in that it indicates that pair-wise octaphonic panning gives something in the neighborhood of Ambisonics! footnote::Maybe that's why people like octaphonic sound?::

(go ahead and quit the server)
code::
s.quit
::
(and close the open plot windows, except for the last one comparing pair-wise and basic HOA3)


subsection:: Spatial Nyquist filters

This isn't completely obvious, and seems counter intuitive, but an expert in windows for filtering will see the two plots as related. The HOA3 law emphasis::looks like:: a smoothed version of the pair-wise law.

Let's do a little experiment.

The pair-wise window for the sine-cosine panning law is actually a zero padded link::https://en.wikipedia.org/wiki/Window_function#Sine_window#Sine window::. footnote::Surprised?::

When we compare the sine window with a windowed sinc, we see some remarkable similarities with our previous plot:

code::
(
~size = 4096;
~numChans = 8;

// pair-wise law
~pairWise8 = Signal.zeroFill(~size).overDub(
	Signal.zeroFill(2 * ~size / ~numChans).addSine(0.5, 1.0, 0.0),
	((~size / 2) - (~size / ~numChans)).asInteger
);

// windowed sinc
~lowpass = Signal.windowedSinc(~size, 0.00085, 1).normalize;  // not far off...

[ ~pairWise8.as(Array), ~lowpass.as(Array) ].lace.plot("Octa: Sine Window & Windowed Sinc", minval: -1, maxval: 1, numChannels: 2)
)
::

A windowed sinc is a lowpass filter. Frequency domain anti-aliasing filters are often designed by starting with a windowed sinc.

For more insight, let's review the frequency response of these two:

code::
(
[
	(~pairWise8.rdftZoom(30, 0, 29).magnitude.normalize + -90.dbamp).ampdb,
	(~lowpass.rdftZoom(30, 0, 29).magnitude.normalize + -90.dbamp).ampdb
].lace.plot("Octa: Sine Window & Windowed Sinc Magnitude (dB)", numChannels: 2)
)
::

What we are seeing here is that the windowed sinc is a fairly well behaved lowpass filter with a flat top and a smooth roll off. This isn't the case with the sine window.

Because we can, let's directly view the frequency response of the HOA3 strict soundfield panning law.

code::
~numChans = 8;
~order = 3;  // ambisonic order

// design decoder
~decoder = HoaMatrixDecoder.newProjection( // design
	Array.regularPolygon(~numChans, \vertex, pi).neg,  // octa
	\basic,  // strict soundfield
	\energy,
	~order
);

// make a new decoder - just the first (front) channel
~frontChanDecoder = HoaMatrixDecoder.newFromMatrix(
	~decoder.getSub(0, 0, ~order.asHoaOrder.size, 1),
	~decoder.directions.keep(1),  // first channel only
	~order
);

// analyze directional response - return basic pan law for HOA3
~testDirections = Array.interpolation(~size, pi.neg, pi);
~basicWindow8 = ~frontChanDecoder.analyzeDirections(~testDirections).amp.as(Signal);


// view pairwise and actual HOA3 law
[ ~pairWise8.as(Array), ~basicWindow8.as(Array) ].lace.plot("Octa: Sine Window & HOA3 Basic", minval: -1, maxval: 1, numChannels: 2);

// frequency response of the two
[
	(~pairWise8.rdftZoom(30, 0, 29).magnitude.normalize + -90.dbamp).ampdb,
	(~basicWindow8.rdftZoom(30, 0, 29).magnitude.normalize + -90.dbamp).ampdb
].lace.plot("Octa: Sine Window & HOA3 Basic Magnitude (dB)", numChannels: 2)
::

What we're seeing is that the HOA3 basic (strict) panning law has a well behaved lowpass response in the frequency domain when viewed as a time domain window.

________________

In the spatial domain, it acts as a emphasis::spatial lowpass filter::. And its role is as a emphasis::spatial anti-aliasing filter::, aka a emphasis::spatial Nyquist fiter::.

Let's see how this works in practice by going back to quad comparing a pair-wise quad law with an HOA3 quad law:

code::
~numChans = 4;
~order = 3;  // ambisonic order

// pair-wise law
~pairWise4 = Signal.zeroFill(~size).overDub(
	Signal.zeroFill(2 * ~size / ~numChans).addSine(0.5, 1.0, 0.0),
	((~size / 2) - (~size / ~numChans)).asInteger
);

// design decoder
~decoder = HoaMatrixDecoder.newProjection( // design
	Array.regularPolygon(~numChans, \vertex, pi).neg,  // quad
	\basic,  // strict soundfield
	\energy,
	~order
);

// make a new decoder - just the first (front) channel
~frontChanDecoder = HoaMatrixDecoder.newFromMatrix(
	~decoder.getSub(0, 0, ~order.asHoaOrder.size, 1),
	~decoder.directions.keep(1),  // first channel only
	~order
);

// analyze directional response - return basic pan law for HOA3
~testDirections = Array.interpolation(~size, pi.neg, pi);
~basicWindow4 = ~frontChanDecoder.analyzeDirections(~testDirections).amp.as(Signal);


// view pairwise and actual HOA3 law
[ ~pairWise4.as(Array), ~basicWindow4.as(Array) ].lace.plot("Quad: Sine Window & HOA3 Basic", minval: -1, maxval: 1, numChannels: 2);

// frequency response of the two
[
	(~pairWise4.rdftZoom(30, 0, 29).magnitude.normalize + -90.dbamp).ampdb,
	(~basicWindow4.rdftZoom(30, 0, 29).magnitude.normalize + -90.dbamp).ampdb
].lace.plot("Quad: Sine Window & HOA3 Basic Magnitude (dB)", numChannels: 2)
::

Remarkably, when we go back to quad from HOA3, we see that the panning law window has opened up again!

This opening up is emphasis::spatial smoothing::, aka emphasis::lowpass filtering:: in the emphasis::spatial domain::.

If we bother to do a check, we'll find that the quad law for HOA3 (when using the emphasis::projection decoder::) is the same as the one for HOA1.

This is a result of the Ambisonic laws applying a emphasis::spatial anti-aliasing filter::.

Also, we can see by inspecting the window frequency response, the spatial cutoff is higher for the octaphonic array. The octaphonic array has a higher emphasis::spatial sampling rate::. For HOA3 with the quadraphonic array, the emphasis::spatial anti-aliasing filter:: rejects spatial detail that would otherwise alias.

In contrast, the pair-wise laws are very leaky. They have higher cutoffs, but significantly more emphasis::spatial aliasing::.

________________

anchor::nyquistTakeways::
strong::Important takeaways::

list::
## emphasis::panning laws:: are emphasis::spatial filters::
## emphasis::spatial smoothing:: is emphasis::spatial lowpass filtering::
## loudspeaker arrays have a emphasis::spatial sampling rate::
## we use emphasis::anti-aliasing filters:: to emphasis::avoid spatial aliasing::
::

(feel free to close any open plots)

subsection:: Isotropy

Maintaining link::https://en.wikipedia.org/wiki/Isotropy##isotropy:: is one of the more important concerns in the design of Ambisonic panning laws.

Let's directly compare the panning laws of pair-wise sine-cosine quad with those of HOA basic quad.

The example code below makes a single window for each law. The directional amplitude and power response of the two arrays are then simulated. The plots returned illustrate these two measures for both arrays.

code::
// ----------------
// single window, to compare
~size = 4096;

~numChans = 4;
~order = 3;  // ambisonic order

// pair-wise law
~pairWise4 = Signal.zeroFill(~size).overDub(
	Signal.zeroFill(2 * ~size / ~numChans).addSine(0.5, 1.0, 0.0),
	((~size / 2) - (~size / ~numChans)).asInteger
);

// design decoder
~decoder = HoaMatrixDecoder.newProjection( // design
	Array.regularPolygon(~numChans, \vertex, pi).neg,  // quad
	\basic,  // strict soundfield
	\energy,
	~order
);

// make a new decoder - just the first (front) channel
~frontChanDecoder = HoaMatrixDecoder.newFromMatrix(
	~decoder.getSub(0, 0, ~order.asHoaOrder.size, 1),
	~decoder.directions.keep(1),  // first channel only
	~order
);

// analyze directional response - return basic pan law for HOA3
~testDirections = Array.interpolation(~size, pi.neg, pi);
~basicWindow4 = ~frontChanDecoder.analyzeDirections(~testDirections).amp.as(Signal);


// pair-wise
~pairWise4Amp = Signal.zeroFill(~size);
~pairWise4Pow = Signal.zeroFill(~size);

// HOA basic
~basicWindow4Amp = Signal.zeroFill(~size);
~basicWindow4Pow = Signal.zeroFill(~size);

~numChans.do({ |i|
	// pair-wise amp & pow
	~pairWise4Amp.overDub(
		~pairWise4.rotate((i / ~numChans * ~size).asInteger)
	);
	~pairWise4Pow.overDub(
		~pairWise4.squared.rotate((i / ~numChans * ~size).asInteger)
	);
	// HOA basic amp & pow
	~basicWindow4Amp.overDub(
		~basicWindow4.rotate((i / ~numChans * ~size).asInteger)
	);
	~basicWindow4Pow.overDub(
		~basicWindow4.squared.rotate((i / ~numChans * ~size).asInteger)
	)
});

// view pairwise and HOA3 law
[ ~pairWise4.as(Array), ~basicWindow4.as(Array) ].lace.plot("Quad Window: Sine & HOA3 Basic", minval: -1, maxval: 1, numChannels: 2);

// view pairwise and HOA3 amp
([ ~pairWise4Amp.normalize.as(Array), ~basicWindow4Amp.normalize.as(Array) ].lace + (-90.dbamp)).ampdb.plot("Quad Amp: Sine & HOA3 Basic (dB)", minval: -5, maxval: 5, numChannels: 2);

// view pairwise and HOA3 pow
([ ~basicWindow4Amp.normalize.as(Array), ~basicWindow4Pow.normalize.as(Array) ].lace + (-90.dbamp)).ampdb.plot("Quad Pow: Sine & HOA3 Basic (dB)", minval: -5, maxval: 5, numChannels: 2);
::

Here's what we see when we inspect these plots:

numberedlist::
## emphasis::both:: the pair-wise and the HOA basic laws are emphasis::equal power::
## emphasis::only:: the HOA basic law is emphasis::equal amplitude::
::

The HOA quad law is emphasis::isotropic:: for both of these measures.

note::
For this review, we've made these measures of the HOA law in a brute force manner. The HOA decoder tools offer the usual formalized measures via a convenient interface. See: link::Classes/HoaMatrixDecoder#Analysis::.
::


section:: Order & harmonics

From the link::Guides/ATK-Glossary:::

definitionlist::
## Ambisonic order
keyword:: order
|| Specifies the maximum emphasis::Associated Legendre degree::, â„“, of a given signal set.
::

emphasis::Ambisonic order:: indicates the emphasis::Associated Legendre degree:: to which the detail of an Ambisonic soundfield is known.

________________

The ATK class tasked with returning SH coefficients is link::Classes/HoaOrder::. This class also returns a variety of performance measures which are useful to consider when seeking to understand the emphasis::meaning of Ambisonic order::.


subsection:: Effective radius & frequency

When we recall the link::Tutorials/ABCs-of-the-ATK#Tetrahedral%20Recording#OUTRS tetrahedral recording experiment::, the origins of Ambisonics as a soundfield sampling technique become clear. The soundfield is sampled at a single point with a measurement array. We emphasis::exactly know the soundfield:: at this point. footnote::Neglecting measurement errors having to do with the actual spatio-frequency response of the microphone. E.g, the spatial aliasing limit of the microphone, and other factors.::

Surprisingly, we also know the soundfield further away from the sampling point, in a frequency dependent way. This is the emphasis::effective radius:::

definitionlist::
## effective radius
|| Radius of the volume (or area) of exact soundfield reconstruction.
::

Let's plot the emphasis::effective radius:: against emphasis::Ambisonic order:::

code::
/*
plot effective radius against effective order
_fixed_ freq
*/
(
~effFreq = 700.0;  // hearing half band
/* ~effFreq = 1000.0;  // hearing duplex theory */

~effOrders = Array.series(10, 0);  // orders to test

~radii = ~effOrders.collect({ |order| HoaOrder.new(order).radiusAtFreq(~effFreq) });
~radii.plot("Effective radius (m) @ % Hz".format(~effFreq), maxval: ~radii.last.ceil);
)
::

Ambisonic order is on the x-axis and effective radius in meters is on the y-axis. We're measuring at 700 Hz (or 1000 Hz, if you choose). This plot illustrates: as Ambisonic order increases, the region of exact soundfield reproduction also increases.

In particular, at 5th order, we can expect a region of nearly radius = 0.4 meter to be emphasis::exactly:: reconstructed for frequencies at and below 700 Hz.

Let's try another plot:

code::
/*
plot effective bandwidth against effective order
_fixed_ radius
*/
(
// choose a radius to test..
// ~effRadius = 1.5;  // @ refRadius
// ~effRadius = 0.5;  // 4 peeps
~effRadius = 0.25;  // 2 peeps
// ~effRadius =  (0.18 / 2);  // head

~effFreq = 700.0;  // hearing half band
/* ~effFreq = 1000.0;  // hearing duplex theory */

~effOrders = Array.series(10, 0);

~effFreqs = ~effOrders.collect({ |order| HoaOrder.new(order).freqAtRadius(~effRadius) });

// log bandwidth
~effFreqs.cpsoct.put(0, 0).plot("Effective octave @ radius % (m)".format(~effRadius), maxval: ~effFreq.cpsoct);
)
::

As with our previous plot, Ambisonic order is on the x-axis. The y-axis is frequency, but on a log scale of decimal octaves. For instance:

code::
5.octcps
::

This plot illustrates: as Ambisonic order increases, the cutoff frequency of exact soundfield reproduction also increases.

In particular, at 3rd order, we can expect a region radius = 0.25 meter to be emphasis::exactly:: reconstructed below 5.3333 decimal octaves:

code::
5.3333.octcps
::

Knowing the effective radius and effective frequency helps us decide which Ambisonic panning law to use. If the target for playback is a large audience, choosing the emphasis::strict soundfield:: law is not necessarily ideal. The emphasis::energy optimised:: or emphasis::controlled opposites:: laws are better choices.

________________

strong::Frequency dependent laws::

Classic FOA employs the emphasis::psycho-acoustic shelf filter:: footnote::link::Classes/FoaPsychoShelf:::: to select the strict law at low frequencies and the energy law at highs. The ATK's HOA toolset includes a fiter kernel designer to do the job. footnote::link::Classes/Signal#*hoaMultiBandFocl:::: Frequency dependent laws have traditionally been advised for studio and nearfield listening. For example:

code::
// --------------------------------------
// find effective freq with respect to radius & order
(
~effRadius = 0.18 / 2;   // head: single listener
~order = 3;

~effFreq = HoaOrder.new(~order).freqAtRadius(~effRadius);
)
::

A single listener can expect a 3rd order soundfield to be reproduced exactly, up to 1820 Hz. Above this point, the energy optimised law is the better choice, as the soundfield isn't exactly reconstructed.


subsection:: Spherical basis functions

From the link::Guides/ATK-Glossary:::

definitionlist::
## spherical harmonics (SH)
keyword:: spherical, harmonic
|| A complete set of orthogonal, Fourier emphasis::basis functions:: on the sphere. For Ambisonics, a set of real form harmonics truncated to a highest emphasis::Associated Legendre:: degree, i.e., a given emphasis::Ambisonic order::, encodes a soundfield. See link::https://en.wikipedia.org/wiki/Spherical_harmonics##Spherical harmonics::.
::


Open the following pages:
code::
(
"https://en.wikipedia.org/wiki/File:Spherical_Harmonics_deg5.png#/media/File:Spherical_Harmonics_deg5.png".openOS;
"https://en.wikipedia.org/wiki/File:Rotating_spherical_harmonics.gif#/media/File:Rotating_spherical_harmonics.gif".openOS;
)
::

The first of these illustrates Spherical Harmonics (SH) up to degree 5; these are the SH for fifth order. We can understand these bubble shapes as illustrating the 3D polar response patterns of each SH. If we like, we can think of these as virtual microphones.

The second illustrates up to degree 4, so these are for fourth order. (We convert a fifth order soundfield to fourth by discarding the SH of degree 5.) These are illustrated as heat maps. Only one side of the "tree" is shown. The symmetries of the sectoral and tesseral SH are shown via the rotating SH.


More from the link::Guides/ATK-Glossary:::

definitionlist::

## sectoral modes
keyword:: sectoral, modes
|| Spherical modes where emphasis::AL degree:: and emphasis::AL index:: are related â„“ = |m|. These modes encode azimuth. See link::https://en.wikipedia.org/wiki/Spherical_harmonics#Visualization_of_the_spherical_harmonics#Visualization of the spherical harmonics:: and link::http://mathworld.wolfram.com/SectorialHarmonic.html##Sectorial Harmonic::.

## tesseral modes
keyword:: tesseral, modes
|| Spherical modes not included as emphasis::sectoral:: or emphasis::zonal::, encoding both azimuth and elevation. See link::https://en.wikipedia.org/wiki/Spherical_harmonics#Visualization_of_the_spherical_harmonics#Visualization of the spherical harmonics:: and link::http://mathworld.wolfram.com/TesseralHarmonic.html##Tesseral Harmonic::.

## zonal modes
keyword:: zonal, modes
|| Spherical modes where emphasis::AL index:: m = 0. These modes encode elevation. See link::https://en.wikipedia.org/wiki/Spherical_harmonics#Visualization_of_the_spherical_harmonics#Visualization of the spherical harmonics:: and link::http://mathworld.wolfram.com/ZonalHarmonic.html##Zonal Harmonic::.
::


The spherical harmonics are the basis functions against which we measure the shape of a soundfield.

A zero-th order soundfield is a soundield without any shape; it has energy only in degree zero.


subsection:: Spherical & angular SSR

It becomes immediately clear that Ambisonic order can be directly understood as a kind of emphasis::spherical domain spatial sampling rate::. The higher the order, the more spherical harmonics.

Let's explore some details. We'll begin by considering:

code::
// three different orders
~hoaOrder1 = 1.asHoaOrder;
~hoaOrder3 = 3.asHoaOrder;
~hoaOrder5 = 5.asHoaOrder;
::

strong::In 3D, aka Periphonic::

How resolved, in terms of numbers of harmonics, are each of these?

code::
~hoaOrder1.size;  // -> 4
~hoaOrder3.size;  // -> 16
~hoaOrder5.size;  // -> 36
::

We see that as order increases, so does the number of SH in the spherical domain. We can think of emphasis::Ambisonic order:: as directly indicating a emphasis::spatial sampling rate:: in the emphasis::spherical domain::.

For translations of soundfields to the emphasis::angular domain::, the ATK uses emphasis::spherical t-designs::. We can find the mimimum size design required for each order by observing the returned error message:

code::
TDesign.newHoa(1, order: ~hoaOrder1.order);  // 4
TDesign.newHoa(1, order: ~hoaOrder3.order);  // 24
TDesign.newHoa(1, order: ~hoaOrder5.order);  // 60
::

strong::3D Soundfield Spatial Sampling Rates::

The table below compares the number of coefficients required for the spherical and angular domains: footnote::Using the energy criteria for t-designs as described by Zotter, et al.

Zotter, F., Frank, M., & Sontacchi, A. (2010). The Virtual T-Design Ambisonics-Rig Using VBAP. EAA Euroregio Ljubljana 2010.
::

table::
## strong::order:: || strong::spherical SR:: || strong::angular SR::
## 1 || 4 || 4
## 3 || 16 || 24
## 5 || 36 || 60
::

One way we can read the table immediately above is to understand that spherical harmonics are a fairly efficient way to represent a soundfield. For fifth order, we need only 36 harmonics, but in the angular domain, emphasis::24 more:: are required for the job.


strong::In 2D, aka Pantophonic::

How resolved, in terms of numbers of harmonics, are each of these?

code::
~hoaOrder1.indices(subset: \sectoral).size;  // -> 3
~hoaOrder3.indices(subset: \sectoral).size;  // -> 7
~hoaOrder5.indices(subset: \sectoral).size;  // -> 11
::

The sectoral harmonics, aka modes, encode the 2D soundfield. You can see we need significantly less harmonics here.

strong::2D Soundfield Spatial Sampling Rates::

The usual practice is to consider the angular sampling rate for 2D to be +1 that of the spherical, as doing so returns more stable image synthesis.

table::
## strong::order:: || strong::spherical SR:: || strong::angular SR::
## 1 || 3 || 4
## 3 || 7 || 8
## 5 || 11 || 12
::

The rule of thumb for 2D arrays is:

code::
~numSpkrs = (~order * 2) + 2
::


subsection::Array resolution

As we saw above with link::#Spatial Nyquist filters::, an actual loudspeaker array has spatial Nyquist frequency. For instance, a quad decoder will only be able to synthesize a first order Ambisonic soundfield. This becomes apparent when we evaluate the rule of thumb immediately above.

For a regular polygon, 2D, we can re-write the rule as: footnote::This will return the number of sectoral harmonics required.::

code::
~order = ((~numSpkrs / 2) - 1).ceil.asInteger
::


The same principle is true for 3D loudspeaker arrays. footnote::There are some specific caveats if we're willing to accept a design that is not isotropic.:: If we are designing an isotropic (equal in space) decoder, the degree of resolution is limited by the number of loudspeakers available. For instance, a cube can emphasis::only:: be first order:

code::
~order = 1;  // yes!
// ~order = 3;  // no!!
~numChans = 8;  // cube

// find t-design
TDesign.newHoa(~numChans, order: ~order);
::


subsection::Localisation measures

Another way we can understand Ambisonic order, and panning law choices (beam shapes) is to consider the localisation measures Ambisonics is designed to optimize:

definitionlist::
## velocity localisation vector (rV)
|| Vector quantity offering an estimate of the perceived localisation of a phantom source at low frequency, predicting imaging up to around 1.5 kHz. Can be found as the real part of emphasis::acoustic admittance::, the emphasis::active acoustic admittance::.

## energy localisation vector (rE)
|| Vector quantity offering an estimate of the perceived localisation of a phantom source in terms of energy, expected to predict imaging between 500 and 5000 Hz.
::

The emphasis::strict soundfield:: option maximizes strong::rV::, where strong::rE:: is emphasis::energy optimised::. For off center listeners, strong::rE:: is usually preferred.

Let's try a plot:

code::
/*
plot rE against order order
beam: energy
*/
(
~beamShape = \energy;  // energy optimised

// ~dim = 3;  // 3D
~dim = 2;  // 2D

~orders = Array.series(10, 0);  // orders to test

~rEs = ~orders.collect({ |order| HoaOrder.new(order).rE(~beamShape, ~dim) });
~rEs.plot("%D: rE for % law".format(~dim, ~beamShape), maxval: ~rEs.last.ceil);
)
::

What we see here is that for a third order 2D array, the energy localisation measure is more that 90% that of a real sound. We expect this energy optimized 2D array to be well defined in terms of energy.

Try:

code::
/*
plot rE against order order
beam: cardioid
*/
(
~beamShape = \controlled;  // controlled opposites

// ~dim = 3;  // 3D
~dim = 2;  // 2D

~orders = Array.series(10, 0);  // orders to test

~rEs = ~orders.collect({ |order| HoaOrder.new(order).rE(~beamShape, ~dim) });
~rEs.plot("%D: rE for % law".format(~dim, ~beamShape), maxval: ~rEs.last.ceil);
)
::

For the emphasis::controlled opposites:: law, we require fifth order to get above the 90% threshold.


section:: Soundfield Model

Near-Field Controlled Ambsionic Soundfield Model
